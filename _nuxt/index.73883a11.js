import{a as Y,r as i,b as T,o as b,e as P,f as w,t as O,u as M,F as L,w as R,h as V,i as z,j as D,k as J,l as Q,m as Z,c as ee}from"./entry.541308c1.js";import{P as I,M as x,C as ae,a as ne}from"./markers.b18db3db.js";const $=100,N=Y("baseKnightStore",()=>{const s=i(0),o=i(0),a=i(0),e=i(0),l=i(0),t=i([]),u=i([]),v=i([]),m=i([]),_=T(()=>{const n=t.value.length,c=t.value.reduce((f,h)=>f+h,0),g=u.value.reduce((f,h)=>f+h,0),y=m.value.reduce((f,h)=>f+h,0),k=v.value.reduce((f,h)=>f+h,0);return{allGames:s.value,allMoves:o.value,allInvalidMoves:a.value,allOptimalMoves:e.value,allTime:l.value,allAverageTimePerTotalMoves:l.value/(o.value+a.value),allAverageTimePerValidMoves:l.value/o.value,allAverageTimePerGame:l.value/s.value,rollingGames:n,rollingMoves:c,rollingInvalidMoves:g,rollingOptimalMoves:y,rollingTime:k,rollingAverageTimePerTotalMoves:k/(c+g),rollingAverageTimePerValidMoves:k/c,rollingAverageTimePerGame:k/n}});function r(n){if(o.value+=n.moves??0,a.value+=n.invalidMoves??0,l.value+=n.ms??0,e.value+=n.optimalMoves??0,t.value.length<$)t.value.push(n.moves??0),u.value.push(n.invalidMoves??0),v.value.push(n.ms??0),m.value.push(n.optimalMoves??0);else{const c=s.value%$;t.value[c]=n.moves??0,u.value[c]=n.invalidMoves??0,v.value[c]=n.ms??0,m.value[c]=n.optimalMoves??0}s.value+=1}return{baseStats:_,applyStats:r}}),te={__name:"StatsDisplay",props:{stats:{type:Object,required:!0}},setup(s){const o=N();return(a,e)=>(b(),P(L,null,[w("pre",null,O(s.stats),1),w("pre",null,O(M(o).baseStats),1)],64))}},q=["a","b","c","d","e","f","g","h"],C=["1","2","3","4","5","6","7","8"],oe=(s,o)=>{if(!o)return[];if(!s)return[];if(s!==I.bn&&s!==I.wn)return[];const a=q.indexOf(o[0]),e=C.indexOf(o[1]);return[[a-2,e-1],[a-2,e+1],[a-1,e-2],[a-1,e+2],[a+1,e-2],[a+1,e+2],[a+2,e-1],[a+2,e+1]].filter(([l,t])=>{const u=l>=0&&l<=7,v=t>=0&&t<=7;return u&&v}).map(([l,t])=>`${q[l]}${C[t]}`)},se=["a","b","c","d","e","f","g","h"],le=["1","2","3","4","5","6","7","8"],G=s=>{const o=se.indexOf(s[0]);return le.indexOf(s[1])*8+o},re=[0,3,2,3,2,3,4,5,3,2,1,2,3,4,3,4,2,1,4,3,2,3,4,5,3,2,3,2,3,4,3,4,2,3,2,3,4,3,4,5,3,4,3,4,3,4,5,4,4,3,4,3,4,5,4,5,5,4,5,4,5,4,5,6],K=[1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1],ie=(s,o)=>{const a=(s|7)-(o|7),e=(s&7)-(o&7);return Math.abs(a)+Math.abs(e)},ce=(s,o)=>{const a=G(s),e=G(o),l=ie(a,e);let t=re[l];return l===9&&(t+=2*(K[a]^K[e])),t},ue={class:"relative"},ve=w("span",null,"Click to play",-1),de={__name:"ChessBoard",props:{piece:{type:String,default:null},start:{type:String,default:null},end:{type:String,default:null},showLegalMoves:{type:Boolean,default:!1}},emits:["start","win","move","invalidMove"],setup(s,{emit:o}){const a=s;let e=null;const l=i(null),t=i(null),u=i(null),v=i(null),m=i(!1),_=T(()=>oe(v.value,t.value)),r=T(()=>t.value!==null&&u.value!==null&&t.value===u.value),n={moves:0,invalidMoves:0,optimalMoves:0,startPerformance:0,endPerformance:0,ms:0},c=x.frame,g=x.dot,y=x.circlePrimary,k=p=>{if(!e||r.value)return;const d=p.target.getAttribute("data-square");if(!d)return;const S=e.getMarkers(c,d);(S==null?void 0:S.length)===0&&(e.removeMarkers(c),e.addMarker(c,d))},f=()=>{e&&e.removeMarkers(c)},h=p=>{if(!e||r.value)return;const d=p.target.getAttribute("data-square");_.value.includes(d)?(n.moves+=1,o("move",{from:t.value,to:d}),e.movePiece(t.value,d),t.value=d):(n.invalidMoves+=1,o("invalidMove",{from:t.value,to:d}))},j=()=>{e&&(e.destroy(),l.value.replaceChildren())},F=()=>{e=new ae(l.value,{assetsUrl:"/chess/",extensions:[{class:ne}]}),e.context.addEventListener("mousedown",h),e.context.addEventListener("mouseover",k),e.context.addEventListener("mouseleave",f)},W=()=>{e&&(!a.piece||!a.start||(v.value=a.piece,t.value=a.start,e.setPiece(t.value,v.value,!0)))},H=()=>{e&&a.end&&(u.value=a.end,e.removeMarkers(y),e.addMarker(y,u.value))},A=()=>{e&&(e.removeMarkers(g),a.showLegalMoves&&!r.value&&_.value.forEach(p=>{e.addMarker(g,p)}))},U=()=>{n.moves=0,n.invalidMoves=0,n.optimalMoves=0,n.startPerformance=performance.now(),n.endPerformance=-1,n.ms=0},B=()=>{j(),U(),F(),W(),H(),A()};R(t,()=>{A()}),R(r,p=>{p&&(e&&(e.removeMarkers(c),e.removeMarkers(g)),n.endPerformance=performance.now(),n.ms=n.endPerformance-n.startPerformance,n.optimalMoves=ce(a.start,a.end),m.value=!1,o("win",n))}),V(()=>{B()});const X=()=>{m.value=!0,o("start"),B()};return(p,d)=>(b(),P("div",ue,[w("div",{ref_key:"boardEl",ref:l},null,512),M(m)?D("",!0):(b(),P("div",{key:0,class:"cursor-pointer bg-gray-300/80 absolute inset-0 flex flex-col items-center justify-center select-none gap-2",onClick:X},[ve,z(p.$slots,"default")]))]))}},me=["a","b","c","d","e","f","g","h"],fe=["1","2","3","4","5","6","7","8"],E=()=>`${me[Math.floor(Math.random()*8)]}${fe[Math.floor(Math.random()*8)]}`,he=w("h1",null,"Base Knight",-1),pe=Z("<p>The Base Knight game trains you on the basic knight moves.</p><h3>fork knight</h3><p>coming soon - find the square that forks two pieces</p><h3>defense knight</h3><p>coming soon - find a square that defends a piece</p><h3>defended knight</h3><p>coming soon - find a square that defends the knight</p><h3>dodge knight</h3><p>coming soon - get to a square while dodging all no-no squares</p><h3>predict knight</h3><p>coming soon - find a square X moves away from the knight</p>",11),_e={__name:"index",setup(s){const o=i(null),a=i(null),e=i(null),l=i(null),t=()=>{o.value=["bn","wn"][Math.floor(Math.random()*2)],a.value=E();let r=E();for(;r===a.value;)r=E();e.value=r},u=r=>{l.value=r,N().applyStats(r),t()},v=r=>{console.log("move: ",r)},m=r=>{console.log("invalid move: ",r)},_=()=>{console.log("started")};return V(()=>{t()}),(r,n)=>{const c=te,g=de;return b(),P(L,null,[he,J(g,{"show-legal-moves":"",piece:M(o),start:M(a),end:M(e),onStart:_,onWin:u,onMove:v,onInvalidMove:m},{default:Q(()=>[M(l)?(b(),ee(c,{key:0,stats:M(l)},null,8,["stats"])):D("",!0)]),_:1},8,["piece","start","end"]),pe],64)}}};export{_e as default};
